### 1. 基本正则表达式:BRE
1. 限定符
	- `^` 用于模式最左侧 , 如 `^a` 表示匹配以a开头的行
	- `$` 用于模式最右侧
	- `.`  匹配非换行符任意一个字符
	- `\`  转义字符
	- `*` 匹配前一个字符(连续出现)任意次, 包括0次
	- `[]` 匹配集合内任一个字符, `[abc]`匹配a,b或c ,除特殊情况外`[]`中的元字符会失去特殊含义
	- `[^]` `[]`的取反,`[^a-z]`匹配所有内容,小写字母除外
```
.*  ## 匹配所有内容
^$  ## 匹配所有空行
^.* ## 匹配任意多个字符开头的内容
.*$ ## 匹配任意多个字符结尾的内容
```

### 2. 扩展正则表达式:ERE
	ERE可以用所有BRE的限定符 , 但是比BRE有更多的内容
1. 限定符
	- `+` 匹配一个字符一次或多次
	- `?` 匹配前一个字符0次或一次
	- `()` 分组 , 如果同个正则前面有分组`\1`表示引用前面分组 , `(?:)` 表示该分组不会被捕获
	- `a{n,m}` 匹配前一个字符最少n次, 最多m次
	- `a{n}`  匹配前一个字符n次
	- `[:/]+` 匹配`:`或 `/`一次或n次
	- `|`   或匹配
	- `(?=)` 正向先行断言 , `=`后匹配的内容不会被匹配 , 但是匹配文本中需要包含 ,写于匹配文本之后
	- (?<=) 正向后行断言 , `=`后匹配的内容不会被匹配 , 但是匹配文本中需要包含 ,写于匹配文本之前
	- `(?!)` 负向先行断言 , `!` 后内容不会被匹配 , 并匹配文本中必须不包含 , 写于匹配文本之后
	- `(?<!)` 负向后行断言 , `!` 后内容不会被匹配 , 并匹配文本中必须不包含 , 写于匹配文本之前
1. 元字符
	- `\d` 匹配数字字符
	- `\D` 数字之外的字符
	- `\w` 英文数字下划线
	- `\W` 非英文数字下划线的任意字符
	- `\b`  标注字符边界,不做真正的匹配，只判断字符是不是独立存在, 类似的有`\<`匹配左边界 , `\>`匹配右边界
	- `\s` 匹配空白字符
	- `\S` 匹配非空白字符

2. 标准字符集 
	 - `[:alnum:]` 字母数字字符。在 ASCII 中，等价于：`[A-Za-z0-9]`
	 - `[:word:]` 与 `[:alnum:]` 相同, 但增加了下划线字符
	 - `[:alpha:]` 字母字符。在 ASCII 中，等价于：`[A-Za-z]`
	 - `[:blank:]` 包含空格和 tab 字符。
	 - `[:digit:]` 数字 0 到 9
	 - `[:lower:]` 小写字母
	 - `[:space:]` 空白字符，包括空格，tab，回车，换行，vertical tab, 和 form feed. 在 ASCII 中，等价于：`[ \t\r\n\v\f]`
	 
3. 标识符
	- `\g` global , 全局标识符 , 如果不启用那么只会匹配第一项
	- `\m` multiline , 多行标识符 , 如果不启用那么将会将所有文本视为一行
	- `\i` case insensitive , 忽略大小写标准

4. 匹配模式
	- 正则表达式默认执行贪婪匹配。这意味着匹配内容会尽可能长
		- `ber beer beeer beeeer` , `.*r`会匹配全部文字
	- 懒惰匹配
		- `ber beer beeer beeeer` , `.*?r`会匹配`ber`

### 三.例
```shell
"^(root|yu)" 
## 匹配root或yu开头的行
"\b[0-9]{2,3}\b"
## 匹配两位或三位的数字,为因为加了\b所以超过三位数的数字不会被匹配到
""
cat passwd
root:x:0:0:root:/root:/bin/bash
grep -E '^([^:]+\b)' passwd -o
## 只打印root,[^:]+\b表示以:结尾但是不包含:的内容
```

