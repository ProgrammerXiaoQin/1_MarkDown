##### 一.shebang
`脚本文件开头的#!,程序会分析shebang后面的内容,作为解释器的指令`
- **#!/bin/sh** 开头的文件,会用bash做解释器
- **#!/usr/bin/python** 开头的文件,会用python解释器去执行
- **#!/usr/bin/env  解释器名称** ,是一种在不同平台上都能找到正确解释器的方法
	`注意事项 `
- 如果未指定`shebang` ,默认用当前shell去解释脚本,即`$SHELL`
- 如果`#!`指定的解释程序不存在,指定的解释器则会被忽略,用默认解释器去执行
	`执行方式`
- `./hello.sh` 给文件添加执行权限直接执行 
- `bash hello.sh` 用bash解释器直接执行,没有执行权限也可以执行



##### 二.shell变量
- 定义变量时,变量与值之间不得有空格
- bash默认把所变量认为是字符串
- shell自定义变量只作用于当前shell
- 单引号变量不识别特殊语法,双引号变量识别特殊语法
	```shell
	name='${奥利给}'
	name2="奥利给"
	name3="${name2}"
	echo name  -> ${奥利给}
	echo name3   ->  奥利给
```

- 每次调用bash/sh解释器执行脚本,都会开启一个子shell,因此不保留当前shell变量
- 调用source或者点符号,会用当前shell环境加载脚本,因此保留,并可以在sh中修改
```bash
	cat test.sh    ->user1="aaa"
	user1="bbb"
	bash test.sh
	echo $user1    ->bbb
	source test.sh  
	echo $uer1     ->aaa
```
- ``` `` ``` 返引号,引用命令执行结果,等于`$()`用法

##### 三.系统变量,特殊变量
1. 环境变量
	`环境变量一般是指用export内置命令导出的变量,用于定义shell运行环境,保证shell命令正确执行,环境变量可以在命令行中临时创建,但用户退出设shell端变量即丢失,要永久生效则需修改配置文件`
- 用户个人配置文件`~/.bash_profile`,远程登陆用户特有文件`~/bashrc`
- 全局配置文件`/etc/profile` , `/etc/bashrc` ,建议在`/etc/profile.d`,并非直接修改主文件,修改全局配置文件影响所有用户
- 个人用户配置文件优先全局配置文件

	`检查系统环境变量`
	- **set**                 输出所有变量，包括环境变量，局部变量
	- **env**                只显示全局变量
	- **declare**          输出所有变量，如set
	- **export**           显示和设置环境变量
	- **unset 变量名** 删除变量或函数
	- **readonly**        设置只读变量,函数

2. 特殊变量
	`参数变量`
- **$0** 获取shell脚本文件名,以及脚本路径
- **$n** 获取shell脚本的第n个参数,n在1~9之间,如$1,$2..$9 ,大于9则需写
\${10},参数空格隔开
- **$#** 获取shel脚本后面的参数个数
- `$*` 获取shell脚本所有参数,加上引号`"$*"` 的作用是把所有参数当成单个字符看待"$1  $2  $3 ...$9"
- $@  获取shell脚本所有参数
- `$*`与`$@`的作用都是获取shell脚本的所有参数,不同的是`$*`加上双引号后会把所有参数当成一个字符看待,`$@` 则不会

	`状态变量`
- **$?**  值为0时表示上一条命令执行成功,1-255为错误码
- **\$\$** 获取当前进程号
- **$!** 上一次后台进程PID
- `$_` 取得上一次命令的最后一个参数

3. 常见系统内置变量
- **$BASH_SUBSHELL**  变量值为0时表示在当前shll执行 


##### 四.内置命令
`注:外置命令一定会开启子进程执行,内置命令不会,内置命令和shell是一体的,系统启动后就存在内存中,compgen -b可以查看所有内置命令`
1. echo               打印
	- -n   不换行输出
	- -e    解析字符串中的特殊符号,类似于printf
	- \\n   换行
	- \\r    回车
	- \\t   制表符  (tab 四个空格)
	- \\b 退格

2. eval        当一个命令前面放上eval时，其结果是shell在执行命令行之前扫描它两次。如：
```shell
pipe="|"
eval ls $pipe wc -l
```
shell第1次扫描命令行时，它替换出pipe的值｜，接着eval使它再次扫描命令行，这时shell把｜作为管道符号了

3. exec       执行命令后自动exit

4. 运算符命令
- let 用于整数运算,类似的有(()),expr,$[]
- awk 可以用于整数或浮点数运算
- declare 定义变量值和属性
```shell
	((i=i+1)) #i+1的值赋值给i
	i=$((i+1))
	echo $((6>7&&3<4)) 
```
- **a++,++a**的区别
	a++,先对变量a操作,再+1
	++a,先计算+1,在赋值给a
```shell
	a=5
	echo $((++a)) ->6
	echo $((a++)) ->6
```
##### 五.语法
1. **${变量}** 返回变量值
2. **${#变量}** 返回变量字符长度
3. **${变量:start}** 截取变量下标start后的字符,包含start
4. **${变量:start:length}** start提取的字符,受length限制
5. **${变量#word}** 从变量开头删除匹配的word,开头不是word不删,支持通配符
6. **${变量##word}** 从变量开头删除匹配的word(贪婪模式)
7. **${变量%word}**  从结尾向前匹配
8. **${变量%\%word}**  从结尾向前匹配(贪婪模式)
```shell
	name="yuchao"
	name2="yuyuyuchao"
	echo ${#name}    ->6
	echo ${name:4}   -> ao
	echo ${name:2:3}   ->cha
	echo ${name#yu}    ->chao
	echo ${name#ch}    ->yuchao
	echo ${name2#*c}  ->hao
	echo ${name2%c*}   ->yuyuyu
```

8. **${变量/pattern/string}** 用string替换找到的第一个pattern
9. **${变量//pattern/string}** 用string替换所有找到的pattern
10. **${parameter:-word}** 如果parmeter为空,返回word
11. **${parameter:=word}** 如果parmeter为空,parmeter== word,并返回word
12. **${parameter:?word}** 如果parmeter为空,word当做stuerr输出
13. **${parameter:+word}** 如果parmeter不为空,返回word 否则什么都不做

14. **()** 用()括起来的语句会明确开启一个子shell运行命令
	`shell脚本开发中,经常用子shell进行多进程处理,提升并发效率.`
	```shell
	(pwd;(ls -l;(echo $BASH_SUBSHELL)))   #其中BASH_SUBSHELL的值为3
```

 

##### 六.通配符
1. `*` 匹配任意多个字符(包括零个或一个)
2. `?` 匹配任意一个字符(不包括零个)
3. ^ 匹配行首
4. $ 匹配行尾
5. **.** 匹配任意字符
6. `[!characters]` 匹配任意一个不是字符集中的字符
```shell
	ls   ->  datea.txt..daten.txt
	ls date[!abc] ->dated.txt..daten.txt
```
4. `[:digit:]` 匹配任意一个数字
5. `[:alpha:]` 匹配任意一个字母
6. `[:lower:]` 匹配任意一个小写字母
7. `[:upper:]` 匹配任意一个大写字母
```shell
	Date??? #匹配任意Date开头,后面跟着三个字符的文件
	[abc]*  #匹配任意a或b或c开头的文件
	backup.[0-9][0-9][0-9] #匹配任意已backup.开头并紧跟三个数字的文件
	[![:digit:]]*  #匹配任意不是数字开头的文件
	*[[:lower:]123]  #匹配任意一个已小写字母或数字1&2&3结尾的文件
```