docker是基于Linux内核的Cgroups, NameSpace ,以及Union FS等技术 , 对进程进行封装隔离 , 属于操作系统层面的虚拟化技术

docker被定义为开源的容器引擎 , 可以方便对容器进行管理 , 包括镜像的打包封装 , 引入Docker Registry对镜像统一管理
#### 一. Docker架构
1. Docker 包括三个基本概念:
	-  **镜像（Image）**：Docker 镜像（Image），就相当于是一个 root 文件系统。比如官方镜像 ubuntu:16.04 就包含了完整的一套 Ubuntu16.04 最小系统的 root 文件系统。
	-   **容器（Container）**：镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。
	-   **仓库（Repository）**：仓库可看成一个代码控制中心，用来保存镜像。


#### 二. Docker安装
1. 配置yum源

3. 更新yum工具 `yum update`

4. 安装`yum install yum-utils device-mapper-persistent-data 1vm2`

5. 安装docker  `yum install docker-ce docker-ce-cli containerd.`
	- 安装时如果提示找不到`docker-ce`包可以更新一下索引, `yum makecache fast`

6. 启用docker
	-  systemctl enable docker
	- systemctl start docker

7. 建立docker用户组
	`docker` 命令会使用Unix socket与 Docker 引擎通讯。只有 `root` 用户和 `docker` 组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux 系统上不会直接使用 `root` 用户。因此，更好地做法是将需要使用 `docker` 的用户加入 `docker` 用户组。
	- `groupadd docker` 建立 `docker` 组
	- usermod -aG docker $USER

8. 镜像加速
	- 在`/etc/docker/daemon.json`中添加:`{"registry-mirrors":["https://reg-mirror.qiniu.com/"]}`
	- 重启服务`systemctl daemon-reload && systemctl restart docker`

#### 二. Docker镜像
1. 获取镜像
	- `docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]`
	- Docker 镜像仓库地址 : 地址的格式一般是 `<域名/IP>[:端口号]`。默认地址是 Docker Hub(`docker.io`)。
	- 这里的仓库名是两段式名称，即 `<用户名>/<软件名>`。对于 Docker Hub，如果不给出用户名，则默认为 `library`，也就是官方镜像。

2. 运行
	- docker run -it --rm ubuntu:18.04 bash
	- `-it`  -i:交互式操作 , -t:终端
	- `--rm`  容器退出后随之将其删除
	- `bash`  指定交互操作的shell

3. 列出镜像`docker image ls [imagename[:标签]]`
	1. `-a` 列出所有镜像(包括中间层镜像)
	2. 指定`imagename`根据仓库名列出镜像
	3. `docker system df` 查看镜像, 容器 , 数据卷占用空间

5. 虚悬镜像
	1. 随着官方镜像维护，发布了新版本后，重新 `docker pull`时镜像名被转移到了新下载的镜像身上，而旧的镜像上的这个名称则被取消，从而成为了 `<none>`。除了 `docker pull` 可能导致这种情况，`docker build` 也同样可以导致这种现象。这类镜像被称为虚悬镜像
		- `docker image ls -f dangling=true` 列出虚悬镜
		- `docker image prune` 删除虚悬镜